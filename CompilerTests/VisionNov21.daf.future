namedef IO = import<daf.iostream>;

namedef MyModule = {
        def moduleName:="MyModule"; //Type [9]char
        typedef named:=trait {
                name:String;
                def _:=constructor(&name:String) {
                    this.name(name); //Up until this point, name is uncertain, and can't be used
                };
                pub def printName:=(&this) {
                    ::IO.print(name);
                };
                prot def kill:(&mut this);
                prot def killAndSayName:=(&mut this) {
                    printName();
                    kill();
                };
                prot virt feed:(&mut this);
                prot virt feedAndSayName:=(&mut this) {
                     printName();
                     feed();
                };
        };
//namedef thisModule = ::MyModule; //pointless
};
namedef _ = MyModule;

typedef Person:=class with named {
        yearsLeft : int;
        def _:=constructor(&name:String, yearsLeft:int) {
            super[0](name);
            this.yearsLeft = yearsLeft;
        };
        def kill:=(&mut this) {
            print("..is now dead");
        };
        def feed:=(&mut this) {
            yearsLeft++;
            print("..is now fed");
        };
        def liveAYear:=(&mut this) {
            yearsLeft--;
            if(yearsLeft<0)
              killAndSayName();
        };
};

def feedNamed(&mut n:named) {
    named.feedAndSayName(); //It is virtual
}

def main:=() {
    let me:Person("haved", 20);
    me.feed();
    me.liveAYear();
    feedNamed(&mut me); we dont cast explicitly, even though the feedNamed may not be deleted. Use owner<T> to keep yourself in check
};

//def a:=() if a > 3 a++; //Not legal for the time being, as statements must be in scopes!