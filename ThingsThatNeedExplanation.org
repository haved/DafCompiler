#+TITLE: Things that need explanation

* Intro
So it's no secret that I'm not particularly knowledgeable when it comes to languages and compilers,
and this compiler is the largest and most complicated piece of software I've ever tried writing.
With the language design and compiler code base being as volatile as they are,
my ability to write clean code is put to the test.
Here I'll note the parts of the code base in particular need of explanation.
If you want to understand anything at all, I recommend you start at the main method.
* The Codebase
** Expressions
*** evaluatesToValue() and needsSemicolonAfterStatement()
These two boolean-returning methods in Expression are used by the statement parser.
Expressions can be statements if =isStatement()= returns true.
Normally statements are followed by semicolons, but statements like if, for, while etc. don't need them.
These special statements actually contain another statement, which often is a scope.
A scope is an expression, defined in Scope.hpp, and it overrides the two methods we started with.
Scopes can evaluate to the last expression, and is thus itself an expression, but it may also not.
In which case, it would be bad if the enclosing scope thought it returned something.
Therefore, a Scope may only have a final out expression that has evaluatesToValue() return true.
In which case the scope itself will do the same, allowing you to chain final out expressions.

needsSemicolonAfterStatement() is also used by the statement parser.
A scope normally doesn't need a trailing semicolon, but if it evaluates to a value,
it behaving like a statement which doesn't becomes weird. To avoid fooling yourself,
a scope returning a value gets the same treatment as any other expression.
Note: This function is by no means pure. It will log a warning if it returns true from a Scope.
That warning will explain why you need a semicolon after the scope, but will be emitted every time.

As a final note and TODO for myself: Do I need two methods? ...or would just one suffice, as they both:
 - return true by default
 - return false for normal scopes
 - return true for scopes that return something

** Functions and defs
When parsing defs, the function signature syntax is used, meaning you can have parameter lists and special return kinds.
This code is all located in parsing/FunctionSignatureParser.cpp
This parsing code is also used when parsing def function types and normal function types, as well as def function expressions and normal function expressions.
Therefore weather or not you can parse compile time parameters is parameterized. A function type without def can't take compile time parameters.
The same goes for weather or not you can eat an equals sign, which can't be done in types, where the equals sign signifies the split between type and expression.
The def parser uses the function type parser to parse its return info even when it doesn't have parameters. There is thus no difference between an empty parameter list and not having one at all.
The type parser also uses it, which makes perfect sense as the entry point is called parseFunctionType and returns a FunctionType.
Although the FunctionType is a type, it is located in FunctionSignature.hpp, for dubious reasons.
** Identifiers
The _ identifier is turned into an identifier with length 0 by the lexer.
This can be problematic as by no means all identifiers can be underscores.
In the future I might make some system where identifiers get assigned numbers from the lexer,
but then you would need a bidirectional map for printing proper error messages.

** Namespaces, Namedefs and NameScopes
A Namespace is anything that contains named definitions, so both a NameScopeExpression (global, unordered), and a normal Scope (ordered definitions and statements) count.
Namedefs are definitions to NameScopeExpressions, a NameScope being one of such, import declarations being another option.
The namedef assigns a name to the NameScopeExpression, allowing you to put them withing each other and reference one another.
The NamespaceStack is used when resolving references in the language. It is pushed and popped when entering NameScopes and normal Scopes,
with the difference being not all identifiers in the Scope being added at once, but rather as you go.
** "Concreteness" OR The dot operator and its troubles
An expression, definition or type being concrete means it and all its children in the AST have resolved all identifier to the corresponding definitions.
With a concrete object, you can find its final target, and e.g. ask for its type in the case of an expression.
Before we try to make things concrete, we add the namespaces to a stack we can search, used to map identifiers to definitions.
You also have the function in Expressions, =tryGetConcreteType()=. It will, once the expression is concrete, give you the type of the expression. Not to an identifier type, but to the actual, canonical(?) type.
The problems occur with the dot operator. When making it concrete, we will always find the left hand side as a definition, but unless this definition is concrete as well, we can't scan the definition for sub-names.
In the case of def, let and typedef, we need to know the type as a concrete type.
** The =try= prefix in function names
It means we won't print an error message upon a failed attempt at doing whatever it is the function tries to do. Instead you'll get a null pointer or something similar
Note that this rule isn't always followed
* The Language

