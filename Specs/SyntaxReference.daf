typedef MyInterface:= interface {
	a:int;
	b:virtual method():int;
	c:virtual method(a:int, b:int):int;
};

typedef MyClass:= class implements MyInterface {
	pub a:int = 40;
	pub b:int = 20;
	def const:=constructor(&mut this, a:int, b:int) {
		this.a = a;
		this.b = b;
	};
	def MyMethod:=(&mut this, a:int) {
		this.a = a;
	};
	def MyConst:=(&this, &mut a:int) {
		a = this.a;
	};
	def MyStatic:=virtual() { //Why it'd be virtual I don't know, but it's possible
		
	};
	def StaticInline:=inline(a:int, b:int):MyClass {
		return altern<a,b>;
	};
	def altern:=<let a:int, let b:int>MyClass.const(a,b);

};

def takeArray:=<T>(array:[]mut T) {
	print(array.length);
};

def main:=() {
	let names:[10] &mut char={"one","two","three","four","five","six","seven","eight","nine","ten"};
	let dynamic:[..]int;
	dynamic.push(20);
	takeArray<&mut char>(names);
	takeArray<int>(dynamic.fixed_mut);

	let dynamic2:&mut[..]=new [20]int={5,2,8,6,9};
	print(dynamic2.pop()); //Prints: '2' or panics if no elm are there. The size is not update by itself
	delete dynamic2;
}
