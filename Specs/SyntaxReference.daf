typedef MyInterface:= interface {
	a:int;
	b:virtual method():int;
	c:virtual method(a:int, b:int):int;
};

typedef MyClass:= class implements MyInterface {
	pub a:int = 40;
	pub b:int = 20;
	def const:=constructor(&mut this, a:int, b:int) {
		this.a = a;
		this.b = b;
	};
	def MyMethod:=(&mut this, a:int) {
		this.a = a;
	};
	def MyConst:=(&this, &mut a:int) {
		a = this.a;
	};
	def MyStatic:=virtual() { //Why it'd be virtual I don't know, but it's possible
		
	};
	def StaticInline:=inline(a:int, b:int):MyClass {
		return altern<a,b>;
	};
	def altern:=<let a:int, let b:int>MyClass.const(a,b);

};

def takeArray:=<T>(array:[]mut T) {
	print(array.length);
};

def main:=() {
	//Having 10 there makes the .length return 10 at compile time. Can also be passed to functions that take [10]&[]char
	let names:[10]&[]char={"one","two","three","four","five","six","seven","eight","nine","ten"};
	let dynamic:&[..]mut int=new [0]int();
	dynamic.push(20);
	takeArray<&mut char>(names);
	takeArray<int>(dynamic.fixed_mut); //Gets you &[]mut int;

	let dynamic2:&mut[..]int=new [20]int({2, 6, 7}, (x:int):int {0}); //The rest are set to 0
	delete dynamic2;
}
