namedef io := import<"daf.iostream">
namedef _ := io;

#if defined(SHARED_MY_LIBRARY) //The hashtag indicates that the scope isn't really a scope
		#with def lib:="../include/mylib.so.1.4"; {
			  linkfile lib;
		    linkfile shared lib; //For the path of the so
		}
#else
    linkfile "../include/mylib.a";

def TEST #if TAST>3 := 4; //Oh?
def BRUH #if defined(TEST) := 6 #else := 8; //Oh yes! (ugly, but slightly useful)

def add<T:Addable>:=(&a:T, &b:T):T {
		a+b
};

def extractOrPanic<T>:=(&a:Optional<T>):T {
		with a as Some(t)
				 return t;
		else; //We need this for the compiler to be happy
    panic("In detroit"); //A panic is an alternative to a return
}

typedef Unpackable<T> := trait {
    def unpacked:T;
		def hasSome:bool;
}

enum Optional<T> {
		 Some(T),
		 None
};

typedef UnpackableOptional<T> := Optional<T> with Unpackable<T> {

}

typedef Unpackable := trait {
    def extract<this:Optional<$T>>:=extractOrPanic<T>as(&this:Optional<T>); //Nice
}

def use := () {
		let f:=Optional.Some(5);
		with f as Unpack;
		//f now implements the trait Unpack, and can be used that way
		printInt(with f as Unpack f.extract()); //Sick
};
