def returnTest := {
	return 4; //Means the def evaluates to 4
	0 //We need to have a final output expression
};

def somethingElse := {
	returnTest //Works just fine, and the return doesn't affect this scope
};

typedef Vec(T) := class {
	mut m_buffer : []T;
	mut capacity:usize;

	pub def move_from := (array:[]T) {
		m_buffer = array;
		capacity = m_buffer.length;
	}

	
};

typedef String := class {
	mut m_buffer : Vec(:char);

	pub def move_from := ctor(array:[]char):This { //A move of an array means we now own the array's content
		m_buffer .= move_from(array);
	};

	pub def _ := ctor(a:String, b:String):This {
		
	};

	pub def length(this:This) := this.m_buffer.length-1;
};

def case := {
	def inner(T) := def(mut a:T) {
		with a as int {
			a++;
		}
	};

	let text : []char = daf_alloc(:char, 20); //We can't really talk about ownership of a pointer. daf_alloc places a usize in front and daf_free handles this fine

	let a := String.();
};