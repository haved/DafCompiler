
typedef Defer(def call) := class {

	pub def _ := ctor():This {};

	pub def delete := inline ctor(mut this:This) {
		call; //Evaluate compile time parameter
	};
};

def add(l:i32, r:i32) := l+r;

def moveInto(T, F/MoveableTo(T), uncrt l:T, mov r:T) := {
	
};

//def case1(a:i32, b:i32) := a*b; //Let's not
def case2 : '(:i32, :i32) = '(a:i32, b:i32) a+b; //:void required to not type-infer
def case3 := (a:i32, b:i32):auto a+b; //Auto required for type inferrence

def test1 := '('uncrt a:i32, 'b:i32) a=b;

def main:=() {
	let a:=malloc(100);
	let b:=Defer( 'free(100) );

	let a:=5;
	let b:=7;

	let mut sum:=add(a,b); //Turns sum into the full expression, replacing a and b with l and r
	sum = add(a+6, a+b); //Puts a+3 and a+b on the stack (let)
};

typedef Defer('freer()) := class {
	def delete := dtor(mut this:This) {
		freer;
	};
};

def main:=() {
	let a:=malloc(128) as [?]mut char;
	let a_keepr := Defer( 'free(a) );

	//Maybe we want to use def instead of quotes?
};