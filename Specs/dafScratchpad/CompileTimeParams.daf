
typedef Defer(def call) := class {

	pub def _ := ctor():This {};

	pub def delete := inline ctor(mut this:This) {
		call; //Evaluate compile time parameter
	};
};

def add(l:i32, r:i32) := l+r;

def moveInto(T, F/MoveableTo(T), uncrt l:T, mov r:T) := {
	
};

def case1(a:i32, b:i32) := a*b;
def case2 : '(:i32, :i32) = '(a:i32, b:i32) a+b; //:void required to not type-infer
def case3 := (a:i32, b:i32):auto a+b; //Auto required for type inferrence

def main:=() {
	let a:=malloc(100);
	let b:=Defer( 'free(100) );

	let a:=5;
	let b:=7;

	let mut sum:=add(a,b); //Turns sum into the full expression, replacing a and b with l and r
	sum = add(a+6, a+b); //Puts a+3 and a+b on the stack (let)
};