#+TITLE: The Daf Grammar

This document details all the grammar currently in the compiler, with descriptions.
I'm, trying to use Backus-Naur Form, but I'll primarily focus on readability and not correctness.
This means I won't bother with <tag markers> all over.

* Definitions
** TODO Add linkfile and namedef to the compilers definition parser
#+BEGIN_SRC BNF
<definition-choice>   ::= let | def | typedef | namedef | with_def | linkfile
<definition>          ::= definition-choice ";"
<global-definition>   ::= "pub" definition | definition
#+END_SRC
** Shared Let & Def
#+BEGIN_SRC BNF
<deflet-expl-impl> ::= ":" type " = " expression | " := " expression
#+END_SRC
** Let
#+BEGIN_SRC BNF
<let-step1> ::= "let" | "let" "mut" | "mut"
<let-step2> ::= let-step1 *identifier*
<let>       ::= let-step2 deflet-expl-impl
#+END_SRC
*** Example use
#+BEGIN_SRC daf
let a := 20
let mut b : u8 = 50
mut c : bool = true
#+END_SRC
** Def
#+BEGIN_SRC BNF
<def-1-keywords> ::= "def"
  .  .  .  .  .  . | "def" let-step1
<def-2-once>  .  ::= def-1-keywords
  .  .  .  .  .  . | def-1-keywords "once"
<def-3-identif>  ::= def-2-once *identifier*
<def-expl-impl>  ::= def-3-identif deflet-expl-impl
<def-scope>   .  ::= "def" *identifier* scope
<def-onlyType>   ::= def-3-identif ":" type
<def-ret-scope>  ::= def-onlyType scope
<def>   .  .  .  ::= def-expl-impl | def-scope | def-onlyType | def-ret-scope
#+END_SRC
*** Example:
#+BEGIN_SRC daf
def val : u8 = 20
def let mut some := b.g
def let once eyo:u8 { let a:=getIndex(); acc[a] }
def print { println("Hello"); }
#+END_SRC
*** TODO Add compile time parameters
*** TODO Add the special scope grammars to the compiler
** Typedef
#+BEGIN_SRC BNF
<typedef> ::= "typedef" *identifier* " := " type
#+END_SRC
*** Example:
#+BEGIN_SRC daf
typedef MyClass := int
typedef MyTrait := u8|i8|u16|i16
#+END_SRC
** Namedef
*** Name-scope-expressions
#+BEGIN_SRC BNF
<name-scope-expression> ::= *identifier*
  .  .  .  .  .  .  .  .  | name-scope-expression "+" name-scope-expression
#+END_SRC

** With (Definition)
Note that a with definition becomes an expression if you follow =<with_def>= with an expression, and not a semicolon
#+BEGIN_SRC BNF
<with_def> ::= "with" expression "as" type
  .   .   .  | "with" ":" type "as" type
#+END_SRC
*** Example
#+BEGIN_SRC daf
with val as u8
with :int as incrementable
#+END_SRC
* Expressions

* Statements
* Types
