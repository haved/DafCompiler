
* Cool features
** Anonymous identifiers
*** As imports
#+BEGIN_SRC daf
namedef IO := import("IO");

def main {
    IO.print(3);
    namedef _ := IO;
	print(5);
};
#+END_SRC
*** As constructors
#+BEGIN_SRC daf
typedef pair(A, B) := class {
    pub first:A;
	pub second:B;

	
};
#+END_SRC
** Classes and traits
*** Implementing traits with 'with'
#+BEGIN_SRC daf
typedef Iterator(T) := trait {
    pub virt def hasNext:bool;
	pub virt def next:T;
	pub virt def skip(steps:i32) {
	    for range(steps)
		    next();
	};
};

pub typedef CountingIterator := class with Iterator(:i32) {
    x:i32;
	end:i32;
	step:i32;

    pub def _(start:i32, end:i32, step:i32):ctor This {
	    this.x=start;
		this.end=end;
		this.step=step;
	};
	pub def _(start:i32, end:i32) := This(start, end, 1);
	pub def _(end:i32) := This(0, end);

	pub def hasNext := x != end;
	pub def next := {
	    x +=step;
		x - step
	};

	pub override def skip(steps:i32) {
	    x += steps*step;
	};
};
#+END_SRC
*** Another way of doing inheritance and implementations and stuff
#+BEGIN_SRC daf
typedef Allocator := trait {
    pub def alloc(size:usize):&mut u8;
	pub def free(ptr:&mut u8);
};

typedef MallocAllocator := class {
    pub virt _ : Allocator;
	pub def alloc(size:usize):&mut u8 = malloc(size);
	pub def free(ptr:&mut u8) { free(ptr); };
};

typedef LinearAllocator := class with Allocator {
    memory:[]mut u8;
	size:usize;
	pub def _(size:usize):ctor This {
	    
	};
    pub def alloc(size:usize):&mut u8 = 
};
#+END_SRC

** Uncert
** Difference between namespaces and types?
