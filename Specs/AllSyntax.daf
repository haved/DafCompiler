import daf.iostream as _;

typedef owner<T> := T;

typdef Circler<T>:=class {
       current:int=0; //Even though it's set in the constructor, you may set it here too
       elms:[]mut T;

       pub def Circler:=constructor(&mut this, size:int, filler:(usize):T, start:int=0) {
           elms = new [size] T (filler);
       };

       //Calling it the same as the class is only allowed for constrcutor and destructors
       def Circler:=destructor(&mut this) {
           delete elms;
       };

       pub def take_array:=constructor(&mut this, elms:owner<[]mut T>, 
       
       pub def getCurrentElement:=(&this):&mut T elms[current];

       //This is equal in all versions of the Circler
       //Yet you don't mark it "don't recompile me"
       //I'll have to optimize away the duplication,
       //because you can't know that current will be in the same memory location,
       //were it not in the first field, before any actual type parameter fields :/
       //Seems too dangerous to let you (&mut this<>) to avoid recompiling.
       //Besides, it's not very exstensible
       pub def advance:=(&mut this) { 
           current++;
           current%=elms.length;
       };
};

typedef Entity:abstract class {
        prot x:float;
        prot y:float;
        prot xSize:float;
        prot ySize:float;

        prot def Entity:=constructor(&mut this, x:float, y:float, xSize:float, ySize:float) {
             this.x = x;
             this.y = y;
             this.xSize = xSize;
             this.ySize = ySize;
             println("Entity created:)");
        };

        //A virtual/abstract destructor is inferred, but here it is anyways
        virtual Entity:=destructor(&mut this) {
                println("Entity being destroyed");      
        }; 

        prot virtual update:=(&mut this) {
             println("I'm a regular Entity");
        };

        //This one would be abstract
        //prot virtual render:(&mut this);
};

typdef Tree:class extends Entity {
       color:[3]u8;

       prot def Tree:=constrcutor(&mut this, x:float, y:float, xSize:float, ySize:float, &color:[3]u8) {
            super.Entity(x, y, xSize, ySize); //The class name, not the constrcutor name
            this.color = color; //Automatic array-copy when both have a compile-time index
            println("It was a tree:)))");
       };

       //The virtual destructor from the Entity is automaticly overritten
       def Tree:=destructor(&mut this) {
           println("No wait, I lied and am a tree being destroyed!\n");
       }

       pub virtual override update:=(&mut this) { //For it to stay virtual, you need to declare it again
           println("I'm a tree");
       };
};

typdef RegularEntity:=class extends Entity {
       pub def RegularEntity:=constrcutor(&mut this, x:float, y:float, xSize:float, ySize:float) {
           super.Entity(x,y,xSize,ySize);
       };
};

def main:=() {
    printRunTime("About to make some entities :)");
    let world:Circler<&unique Entity>(4, (i:usize):&unique Entity {i%2==1?new &unique Tree(2, 2, i, 2, {2,i,2}):new &unique RegularEntity(i,i,4,4)});
    for(i:=0;i<20;i++) {
        world.getCurrentElement().update();
        world.advance();
    }
    printCompileTime!("All entities about to die :(");

    let mut a:int=4;
    def mut b:=a;

    if(b++<a) {
       print("It works!");
    }
    orif(b==a) { //Yes, in one word :)
       print("Even more works!");
    }
    //else is not possible here.
}

def printRunTimeParam:=(&a:[]char)println(a);
def printCompileTime<def a:[]char>:=println(a);