let mut f:=5;
def let g:=f; //lvalue but immutable
def h:=5; //Not an lvalue
def c:=&mut f; //Not an lvalue
def /*let*/ mut d:=@c; //Mutable lvalue, sey let if you want to
d++;

def func:=() { //A normal function

};

def swap:=$(T:Assignable)(&mut a:T, &mut b:T) { //A function with a template
	let temp:= a;
	a = b;
	b = a;
};

def swapAndGet:=inline(&mut struct:MyStruct):int { //Inline function mimicing the syntax of normal functions
	swap!(&mut int)(mut struct.current, mut struct.other);
	return @struct.current;
};

def swapAndGetTwo:$(def mut MyStruct):mut int=$(def struct:MyStruct):mut int { //True inline with only compile-time args
	swap!(&mut int)(mut struct.current, mut struct.other);
	return @struct.current; //Gives you a mutable lvalue in this case
};

def timesTwo:=$(def a:$T):T a*2; //Of type $(def $T):T //True inline function

typedef MyStruct := class {
	a:int;
	b:int;
	pub current:&mut int;
	pub other:&mut int;
	pub def make := constructor(&mut this, a:int, b:int) {
		this.a = a;
		this.b = b;
		this.current = &mut a;
		this.other = &mut b;
	};
};

def main:=() {
	let myTwo:=MyStruct.make(30, 40); //Curr: 30
	assertEquals(swapAndGet(mut myTwo), 40); //Curr: 40
	swapAndGetTwo!() = 20; //Curr: 20, Other: 40
	assertEquals(@myTwo.current, timesTwo!(10));
	assertEquals(@myTwo.other,   timesTwoQuick<20>);
};
