let mut f:=5;
def let g:=f; //lvalue but immutable
def h:=5; //Not an lvalue
def c:=&mut f; //Not an lvalue
def /*let*/ mut d:=@c; //Mutable lvalue, sey let if you want to
d++;

def func:=() { //A normal function

};

def swap:=$(T implements Assignable)(&mut a:T, &mut b:T) { //A function with a template
	let temp:= a;
	a = b;
	b = a;
};

def swapAndGet:=inline(&struct:MyStruct):int { //Inline function mimicing the syntax of normal functions
	swap!(&mut int)(struct.current,struct.other);
	return @struct.current;
};

def swapAndGetTwo:$(def MyStruct):mut int=$(def struct:MyStruct):mut int { //True inline with only compile-time args
	swap!(&mut int)(mut struct.current,mut struct.other);
	return @struct.current; //Gives you a mutable lvalue in this case
};

def timesTwo:=$(def a:$T):T a*2; //Of type $(def $T):T //True inline function

def timesTwoQuick:=<def a:int> a*2; //Of type int, but needs to have an integer passed

typedef MyStruct := class {
	a:int;
	b:int;
	pub current:&mut int;
	pub other:&mut int;
	pub def make := constructor(&mut this, a:int, b:int) {
		this.a = a;
		this.b = b;
		this.current = &mut a;
		this.other = &mut b;
	};
};

def main:=() {
	MyStruct 
};
