import string, memcpy from daf.memory;

pub class String<T> {
    text:&T;
    final len:int; //Perhaps a final keyword?

    pub String(text:&T) {
        len = strlen(text);
        this->text = new T[len+1];
        memcpy_type(this->text, text, len+1); //memcpy_type takes a template type. length *= sizeof(T);
    }

    pub String(&other:String<T>) {
        len = other.len;
        text = new T[len+1];
        memcpy_type(text, other.text, len+1);
    }

    pub String(&move other:String<T>) { //move semantics imply that the refrence is also mutable
        len = other.len;
        text = other.text;
        other.text = null;
    }

    pub ~String() { //If the class was virtual, demand that this too is virtual
        delete[] text; //Checks if it's 0 automaticly
    }

    pub const method get():&T {
        return text;
    }
};

pub typedef string String<char>; //Guess I'll have typedef